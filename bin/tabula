#!/usr/bin/env jruby
# encoding: utf-8
require 'trollop'
require_relative '../lib/tabula'

FORMATS = ['CSV', 'TSV', 'HTML', 'JSON']

def parse_pages_arg(pages_arg)
  ranges = pages_arg.split(',').map(&:strip)
  pages = []
  ranges.each do |range|
    s, e = range.split('-')
    return nil if (s.nil? && e.nil?) || s !~ /\d+/ || (!e.nil? && e !~ /\d+/)
    if e.nil?
      pages << s.to_i
    else
      return nil if s.to_i > e.to_i
      pages += (s.to_i..e.to_i).to_a
    end
  end
  pages.sort
end

def parse_command_line
  opts = Trollop::options do
    version "tabula #{Tabula::VERSION} (c) 2012-2013 Manuel Aristar√°n"
    banner <<-EOS
Tabula helps you extract tables from PDFs

Usage:
       tabula [options] <pdf_file>
where [options] are:
EOS

    opt :pages, 'Comma separated list of ranges. Examples: --pages 1-3,5-7 or --pages 3. Default is --pages 1', :default => '1', :type => String
    opt :password, 'Password to decrypt document. Default is empty', :default => ''
    opt :debug, 'Print detected table areas instead of processing.'
    opt :format, "Output format (#{FORMATS.join(",")})", :default => 'CSV'
    opt :outfile, 'Write output to <file> instead of STDOUT', :default => '-'
  end

  Trollop::die :format, "is unknown" unless FORMATS.include?(opts[:format])
  Trollop::die "need one filename" if ARGV.empty?

  pdf_filename = ARGV.shift
  Trollop::die 'file does not exist' unless File.exists? pdf_filename

  return opts, pdf_filename
end

def main
  opts, filename = parse_command_line

  area = opts[:area].nil? ? nil : opts[:area].split(',').map(&:to_f)
  vertical_rulings = opts[:columns].nil? ? nil : opts[:columns].split(',').map(&:to_f)
  out = opts[:outfile] == '-' ? $stdout : File.new(opts[:outfile], 'wb')

  extractor = Tabula::Extraction::SpreadsheetExtractor.new(filename, parse_pages_arg(opts[:pages]), opts[:password])
  extractor.extract.each do |pdf_page, spreadsheet|
    if opts[:debug]
      puts "Page #{pdf_page}: #{spreadsheet.dims(:top, :left, :bottom, :right)}"
    else
      Tabula::Writers.send(opts[:format].to_sym,
                          spreadsheet.rows,
                          out)
    end

  end
  out.close
end

main
